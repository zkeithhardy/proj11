/*
 * Authors: Haoyu Song and Dale Skrien
 * Date: Spring and Summer, 2018
 *
 * In the grammar below, the variables are enclosed in angle brackets.
 * The notation "::=" is used instead of "-->" to separate a variable from its rules.
 * The special character "|" is used to separate the rules for each variable.
 * All other symbols in the rules are terminals.
 * EMPTY indicates a rule with an empty right hand side.
 * All other terminal symbols that are in all caps correspond to keywords.
 */
package proj19KeithHardyLiLian.bantam.parser;

import static proj19KeithHardyLiLian.bantam.lexer.Token.Kind.*;

import proj19KeithHardyLiLian.bantam.builder.ASTNodeBuilder;
import proj19KeithHardyLiLian.bantam.lexer.Scanner;
import proj19KeithHardyLiLian.bantam.lexer.Token;
import proj19KeithHardyLiLian.bantam.util.Error;
import proj19KeithHardyLiLian.bantam.util.ErrorHandler;
import proj19KeithHardyLiLian.bantam.ast.*;
import proj19KeithHardyLiLian.bantam.util.CompilationException;

import java.util.HashMap;
import java.util.List;

/**
 * This class constructs an AST from a legal Bantam Java program.  If the
 * program is illegal, then one or more error messages are displayed.
 */
public class Parser
{
    // instance variables
    private Scanner scanner;
    private Token currentToken; // the lookahead token
    private ErrorHandler errorHandler;
    private String filename;
    private ASTNodeBuilder astNodeBuilder;
    private HashMap<Integer, String> commentMap;

    // constructor
    public Parser(ErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
        this.astNodeBuilder = new ASTNodeBuilder();
    }

    public HashMap<Integer,String> getCommentMap(){
        return this.commentMap;
    }


    /**
     * parse the given file and return the root node of the AST
     * @param filename The name of the Bantam Java file to be parsed
     * @return The Program node forming the root of the AST generated by the parser
     */
    public Program parse(String filename) {
        this.scanner=new Scanner(filename, this.errorHandler);
        this.filename=filename;
        commentMap = new HashMap<>();
        return this.parseProgram();
    }

    public static void main(String[] argv){
        if(argv.length == 0){
            System.out.println("Please Provide Test Files");
            return;
        }

        for(String filename: argv) {
            ErrorHandler errorHandler = new ErrorHandler();
            Parser parser = new Parser(errorHandler);

            try {
                parser.parse(filename);
                System.out.println("Parsing Successful.");
            }catch(CompilationException e){
                if(errorHandler.errorsFound()){
                    System.out.println(filename + ": Parsing Failed");
                    List<Error> errorList= errorHandler.getErrorList();
                    for(Error error:errorList ){
                        System.out.println(error.toString() + "\n");
                    }
                }else{
                    System.out.println("Invalid filename: "+filename);
                }
            }
        }
    }


    /*
     * <Program> ::= <Class> | <Class> <Program>
     */
    private Program parseProgram(){
        updateCurrentToken();
        int position = currentToken.position;
        ClassList classList = astNodeBuilder.buildClassList(position);//new ClassList(position);

        while (currentToken.kind != EOF) {
            Class_ aClass = parseClass();
            classList.addElement(aClass);
            updateCurrentToken();
        }
        return astNodeBuilder.buildProgram(position, classList);//new Program(position, classList);
    }


    /*
	 * <Class> ::= CLASS <Identifier> <ExtendsClause> { <MemberList> }
     * <ExtendsClause> ::= EXTENDS <Identifier> | EMPTY
     * <MemberList> ::= EMPTY | <Member> <MemberList>
     */
    private Class_ parseClass() {
        int position = currentToken.position;
        String parent="";
        MemberList memberList= new MemberList(position);
        this.checkToken(CLASS,"When parsing class, class expected." );
        String name = parseIdentifier();

        if (currentToken.kind==EXTENDS){
            updateCurrentToken();
            parent =parseIdentifier();
        }

        this.checkToken(LCURLY,"When parsing class, \"{\" expected.");

        while (currentToken.kind!= RCURLY){
            if (currentToken.kind == EOF){
                this.registerError("When parsing class, \"}\" expected.",
                        "Unexpected Token");
            }
            memberList.addElement(parseMember());
        }
        return astNodeBuilder.buildClass(position,filename, name, parent, memberList);//new Class_(position,filename,name, parent, memberList);
    }


    /* Fields and Methods
     * <Member> ::= <Field> | <Method>
     * <Method> ::= <Type> <Identifier> ( <Parameters> ) <Block>
     * <Field> ::= <Type> <Identifier> <InitialValue> ;
     * <InitialValue> ::= EMPTY | = <Expression>
     */
     private Member parseMember() {
         int position= currentToken.position;
         FormalList formalList;
         StmtList stmtList;
         Expr expr;

         //return type
         String type =parseType();

         //name
         String identifier =parseIdentifier();

         if(currentToken.kind == LPAREN){
             //Method case
            updateCurrentToken();
            formalList=parseParameters();
            updateCurrentToken();
            BlockStmt block = (BlockStmt)this.parseBlock();
            stmtList = block.getStmtList();
            return astNodeBuilder.buildMethod(position, type, identifier, formalList, stmtList);//new Method(position,type, identifier, formalList, stmtList );
        }

         else if (currentToken.kind== ASSIGN){
             //non-empty field case
             updateCurrentToken();
             expr=parseExpression();
             this.checkToken(SEMICOLON, "When parsing field, \";\" expected.");
             return astNodeBuilder.buildField(position, type, identifier, expr);//new Field(position, type, identifier, expr);

         }

         else if (currentToken.kind==SEMICOLON){
             //empty field case
             updateCurrentToken();
             return astNodeBuilder.buildField(position,type,identifier,null);//new Field(position,type, identifier, null);
         }
         else {
             this.registerError("When parsing field, \"(\", \"=\", or \";\" expected.",
                     "Unexpected Token");
         }
         return null;
     }


    //-----------------------------------

    /* Statements
     *  <Stmt> ::= <WhileStmt> | <ReturnStmt> | <BreakStmt> | <DeclStmt>
     *              | <ExpressionStmt> | <ForStmt> | <BlockStmt> | <IfStmt>
     */
     private Stmt parseStatement() {
            Stmt stmt;

            switch (currentToken.kind) {
                case IF:
                    stmt = parseIf();
                    break;
                case LCURLY:
                    stmt = parseBlock();
                    break;
                case VAR:
                    stmt = parseDeclStmt();
                    break;
                case RETURN:
                    stmt = parseReturn();
                    break;
                case FOR:
                    stmt = parseFor();
                    break;
                case WHILE:
                    stmt = parseWhile();
                    break;
                case BREAK:
                    stmt = parseBreak();
                    break;
                default:
                    stmt = parseExpressionStmt();
            }

            return stmt;
    }


    /*
     * <WhileStmt> ::= WHILE ( <Expression> ) <Stmt>
     */
    private Stmt parseWhile() {
        int position = this.currentToken.position;
        updateCurrentToken();
        this.checkToken(LPAREN,"When parsing while, \"(\" expected.");
        Expr predExpr = this.parseExpression();

        this.checkToken(RPAREN,"When parsing while, \")\" expected.");
        return astNodeBuilder.buildWhileStmt(position,predExpr,this.parseStatement());//new WhileStmt(position, predExpr, this.parseStatement());
    }


    /*
     * <ReturnStmt> ::= RETURN <Expression> ; | RETURN ;
     */
	private Stmt parseReturn() {
	    updateCurrentToken();
	    int position = this.currentToken.position;
	    if(this.currentToken.kind == SEMICOLON){
	        updateCurrentToken();
	        return astNodeBuilder.buildReturnStmt(position,null);//new ReturnStmt(position, null);
        }else{
	        Expr expr = this.parseExpression();
	        this.checkToken(SEMICOLON, "When parsing Return, \";\" expected.");
            return astNodeBuilder.buildReturnStmt(position,expr);//new ReturnStmt(position,expr);
        }
    }


    /*
	 * BreakStmt> ::= BREAK ;
     */
	private Stmt parseBreak() {
	    updateCurrentToken();
	    int position = this.currentToken.position;
	    this.checkToken(SEMICOLON,"When parsing Break, \";\" expected");
        return astNodeBuilder.buildBreakStmt(this.currentToken.position);//new BreakStmt(this.currentToken.position);
    }


    /*
	 * <ExpressionStmt> ::= <Expression> ;
     */
	private ExprStmt parseExpressionStmt() {
	    Expr expr = this.parseExpression();
	    int position = this.currentToken.position;
	    this.checkToken(SEMICOLON, "When parsing ExpressionStmt\";\" expected");
	    return astNodeBuilder.buildExprStmt(position,expr);//new ExprStmt(position,expr);
    }


    /*
	 * <DeclStmt> ::= VAR <Identifier> = <Expression> ;
     * every local variable must be initialized
     */
	private Stmt parseDeclStmt() {
	    updateCurrentToken();
	    int position = this.currentToken.position;
	    String name = this.parseIdentifier();

	    this.checkToken(ASSIGN, "When parsing DeclStmt, \"=\" expected");
        Expr expr = this.parseExpression();

        this.checkToken(SEMICOLON,"When parsing DeclStmt, \";\" expected");
        return astNodeBuilder.buildDeclStmt(position,name,expr);//new DeclStmt(position,name,expr);
    }



    /*
	 * <ForStmt> ::= FOR ( <Start> ; <Terminate> ; <Increment> ) <STMT>
     * <Start>     ::= EMPTY | <Expression>
     * <Terminate> ::= EMPTY | <Expression>
     * <Increment> ::= EMPTY | <Expression>
     */
	private Stmt parseFor() {
        int position = this.currentToken.position;
        updateCurrentToken();

        this.checkToken(LPAREN, "When parsing For, \"(\" expected");
        Expr startExpr = this.parseExpression();

        this.checkToken(SEMICOLON,"When parsing For, \";\" expected");
        Expr predExpr = this.parseExpression();

        this.checkToken(SEMICOLON, "When parsing For, \";\" expected");
        Expr incExpr = this.parseExpression();

        this.checkToken(RPAREN,"When parsing For, \")\" expected");
        return astNodeBuilder.buildForStmt(position,startExpr,predExpr,incExpr,this.parseStatement());//new ForStmt(position, startExpr, predExpr, incExpr, this.parseStatement());
    }


    /*
	 * <BlockStmt> ::= { <Body> }
     * <Body> ::= EMPTY | <Stmt> <Body>
     */
	private Stmt parseBlock() {
        int position = this.currentToken.position;
        StmtList stmtList = astNodeBuilder.buildStmtList(position);//new StmtList(position);
        this.checkToken(LCURLY,"When parsing Block\"{\" expected" );

        while(this.currentToken.kind != RCURLY){
            if (currentToken.kind == EOF){
                this.registerError("When parsing Block\"}\" expected","Unexpected Token");
            }
            stmtList.addElement(this.parseStatement());

        }
        updateCurrentToken();
	    return astNodeBuilder.buildBlockStmt(position,stmtList);//new BlockStmt(position, stmtList);
    }


    /*
	 * <IfStmt> ::= IF ( <Expr> ) <Stmt> | IF ( <Expr> ) <Stmt> ELSE <Stmt>
     */
	private Stmt parseIf() {
	    int position = this.currentToken.position;
        Stmt elseStmt;
        updateCurrentToken();

        this.checkToken(LPAREN, "When parsing If, \"(\" expected");
        Expr predExpr = this.parseExpression();

        this.checkToken(RPAREN,"When parsing If, \")\" expected");
        Stmt thenStmt = this.parseStatement();

        if(this.currentToken.kind == ELSE){
            updateCurrentToken();
            elseStmt = this.parseStatement();
        }
        else{
            elseStmt = null;
        }
        return astNodeBuilder.buildIfStmt(position,predExpr,thenStmt,elseStmt);//new IfStmt(position, predExpr, thenStmt, elseStmt);
    }


    //-----------------------------------------
    // Expressions
    //Here we introduce the precedence to operations

    /*
	 * <Expression> ::= <LogicalOrExpr> <OptionalAssignment>
     * <OptionalAssignment> ::= EMPTY | = <Expression>
     */
	private Expr parseExpression(){
        int position = this.currentToken.position;
        Expr left = this.parseOrExpr();

        if (this.currentToken.kind == ASSIGN){
            if (left instanceof VarExpr){
                String refName = null;
                if(((VarExpr) left).getRef() != null) {
                    refName = ((VarExpr) ((VarExpr) left).getRef()).getName();
                }
                String name = ((VarExpr) left).getName();
                Expr right;
                switch(this.currentToken.spelling){
                    case("+="):
                        updateCurrentToken();
                        right = new BinaryArithPlusExpr(position,left,this.parseExpression());
                        break;
                    case("-="):
                        updateCurrentToken();
                        right = new BinaryArithMinusExpr(position,left,this.parseExpression());
                        break;
                    case("*="):
                        updateCurrentToken();
                        right = new BinaryArithTimesExpr(position,left,this.parseExpression());
                        break;
                    case("/="):
                        updateCurrentToken();
                        right = new BinaryArithDivideExpr(position,left,this.parseExpression());
                        break;

                    default:
                        updateCurrentToken();
                        right = this.parseExpression();
                }


                return astNodeBuilder.buildAssignExpr(position,refName,name,right);//new AssignExpr(position,refName,name,this.parseExpression());
            }
            else if(left instanceof ArrayExpr){
                String refName = null;
                if(((ArrayExpr) left).getRef() != null) {
                    refName = ((VarExpr) ((ArrayExpr) left).getRef()).getName();
                }
                String name = ((ArrayExpr) left).getName();
                Expr index = ((ArrayExpr) left).getIndex();
                Expr right;
                switch(this.currentToken.spelling){
                    case("+="):
                        updateCurrentToken();
                        right = new BinaryArithPlusExpr(position,left,this.parseExpression());
                        break;
                    case("-="):
                        updateCurrentToken();
                        right = new BinaryArithMinusExpr(position,left,this.parseExpression());
                        break;
                    case("*="):
                        updateCurrentToken();
                        right = new BinaryArithTimesExpr(position,left,this.parseExpression());
                        break;
                    case("/="):
                        updateCurrentToken();
                        right = new BinaryArithDivideExpr(position,left,this.parseExpression());
                        break;

                    default:
                        updateCurrentToken();
                        right = this.parseExpression();
                }
                return astNodeBuilder.buildArrayAssignExpr(position,refName,name,index,right);//new ArrayAssignExpr(position,refName,name,index, this.parseExpression());
            }
            else{
                this.registerError("When parsing Expr, Variable name Expected",
                        "Error in parsing expression");
            }

        }
        else{
            return left;
        }
        return null;
    }


    /*
	 * <LogicalOR> ::= <logicalAND> <LogicalORRest>
     * <LogicalORRest> ::= EMPTY |  || <LogicalAND> <LogicalORRest>
     */
	private Expr parseOrExpr() {
        int position = currentToken.position;

        Expr left = parseAndExpr();
        while (this.currentToken.spelling.equals("||")) {
            updateCurrentToken();
            Expr right = parseAndExpr();
            left = astNodeBuilder.buildBinaryLogicOrExpr(position,left,right);//new BinaryLogicOrExpr(position, left, right);
        }

        return left;
	}

    //-------------------------------------------------------
    /*
	 * <LogicalAND> ::= <ComparisonExpr> <LogicalANDRest>
     * <LogicalANDRest> ::= EMPTY |  && <ComparisonExpr> <LogicalANDRest>
     */
	private Expr parseAndExpr() {
	    int position =currentToken.position;
	    Expr left= parseEqualityExpr();
	    while (this.currentToken.spelling.equals("&&")){
	        updateCurrentToken();
	        Expr right=parseEqualityExpr();
	        left= astNodeBuilder.buildBinaryLogicAndExpr(position,left,right);//new BinaryLogicAndExpr(position,left, right);

        }
        return left;
    }


    /*
	 * <ComparisonExpr> ::= <RelationalExpr> <equalOrNotEqual> <RelationalExpr> |
     *                     <RelationalExpr>
     * <equalOrNotEqual> ::=  == | !=
     */
	private Expr parseEqualityExpr() {
	    int position= currentToken.position;
	    Expr left = parseRelationalExpr();
	    String operator = this.parseOperator();
	    if(operator.equals("==")){
	        updateCurrentToken();
	        Expr right= parseRelationalExpr();
	        left=astNodeBuilder.buildBinaryCompEqExpr(position,left,right);//new BinaryCompEqExpr(position,left,right);
        }
        else if(operator.equals("!=")){
            updateCurrentToken();
            Expr right= parseRelationalExpr();
            left=astNodeBuilder.buildBinaryCompNeExpr(position,left,right);//new BinaryCompNeExpr(position,left,right);
        }
	    return left;
    }

    //------------------------------------------------------------
    /*
	 * <RelationalExpr> ::=<AddExpr> | <AddExpr> <ComparisonOp> <AddExpr>
     * <ComparisonOp> ::=  < | > | <= | >= | INSTANCEOF
     */
	private Expr parseRelationalExpr() {
	    int position = this.currentToken.position;
	    Expr left = this.parseAddExpr();
	    String operator = this.parseOperator();
        switch (operator) {
            case "<":
                updateCurrentToken();
                return astNodeBuilder.buildBinaryCompLtExpr(position,left,this.parseAddExpr());//new BinaryCompLtExpr(position, left, this.parseAddExpr());
            case "<=":
                updateCurrentToken();
                return astNodeBuilder.buildBinaryCompLeqExpr(position,left,this.parseAddExpr());//new BinaryCompLeqExpr(position, left, this.parseAddExpr());
            case ">":
                updateCurrentToken();
                return astNodeBuilder.buildBinaryCompGtExpr(position,left,this.parseAddExpr());//new BinaryCompGtExpr(position, left, this.parseAddExpr());
            case ">=":
                updateCurrentToken();
                return astNodeBuilder.buildBinaryCompGeqExpr(position,left,this.parseAddExpr());//new BinaryCompGeqExpr(position, left, this.parseAddExpr());
            case "instanceof":
                updateCurrentToken();
                return astNodeBuilder.buildInstanceOfExpr(position,left, this.parseType()); //new InstanceofExpr(position, left, this.parseType());
            default:
                return left;
        }
    }

    //-----------------------------------------------------------------
    /*
	 * <AddExpr>::＝ <MultExpr> <MoreMultExpr>
     * <MoreMultExpr> ::= EMPTY | + <MultExpr> <MoreMultExpr> | - <MultExpr> <MoreMultExpr>
     */
	private Expr parseAddExpr() {
        int position = this.currentToken.position;

        Expr left = parseMultExpr();
        while (this.currentToken.spelling.equals("+") || this.currentToken.spelling.equals("-")) {
            if(this.currentToken.spelling.equals("+")){
                updateCurrentToken();
                Expr right = parseMultExpr();
                left = astNodeBuilder.buildBinaryArithPlusExpr(position,left,right);//new BinaryArithPlusExpr(position, left, right);
            }
            else if(this.currentToken.spelling.equals("-")){
                updateCurrentToken();
                Expr right= parseMultExpr();
                left = astNodeBuilder.buildBinaryArithMinusExpr(position,left,right);//new BinaryArithMinusExpr(position, left, right);
            }

        }
        return left;
    }


    /*
	 * <MultiExpr> ::= <NewCastOrUnary> <MoreNCU>
     * <MoreNCU> ::= * <NewCastOrUnary> <MoreNCU> |
     *               / <NewCastOrUnary> <MoreNCU> |
     *               % <NewCastOrUnary> <MoreNCU> |
     *               EMPTY
     */
	private Expr parseMultExpr() {
        int position = this.currentToken.position;

        Expr left = parseNewCastOrUnary();
        Expr right;
        while (this.currentToken.spelling.equals("*") || this.currentToken.spelling.equals("/")
                || this.currentToken.spelling.equals("%")) {
            switch(this.currentToken.spelling) {
                case "*":
                    updateCurrentToken();
                    right = parseNewCastOrUnary();
                    left = astNodeBuilder.buildBinaryArithTimesExpr(position,left,right);//new BinaryArithTimesExpr(position, left, right);
                    break;
                case "/":
                    updateCurrentToken();
                    right = parseNewCastOrUnary();
                    left = astNodeBuilder.buildBinaryArithDivideExpr(position,left,right);//new BinaryArithDivideExpr(position, left, right);
                    break;
                case "%":
                    updateCurrentToken();
                    right = parseNewCastOrUnary();
                    left = astNodeBuilder.buildBinaryArithModulusExpr(position,left,right);//new BinaryArithModulusExpr(position, left, right);
                    break;
            }
        }

        return left;
    }

    //-----------------------------------
    /*
	 * <NewCastOrUnary> ::= < NewExpression> | <CastExpression> | <UnaryPrefix>
     */
	private Expr parseNewCastOrUnary() {
        Expr castOrUnary;
        if(this.currentToken.kind == NEW){
            castOrUnary=parseNew();
        }
        else if(this.currentToken.kind == CAST){
            castOrUnary=parseCast();
        }
        else{
            castOrUnary=parseUnaryPrefix();
        }
	    return castOrUnary;
    }


    /*
	 * <NewExpression> ::= NEW <Identifier> ( ) | NEW <Identifier> [ <Expression> ]
     */
	private Expr parseNew() {
	    updateCurrentToken();
	    String id = this.parseIdentifier();
	    if(this.currentToken.kind == LPAREN){
            updateCurrentToken();
            this.checkToken(RPAREN,"When parsing New, \")\" expected");
            return astNodeBuilder.buildNewExpr(this.currentToken.position,id);//new NewExpr(this.currentToken.position,id);
        }else if(this.currentToken.kind == LBRACKET){
            updateCurrentToken();
            Expr expr = this.parseExpression();
            if(expr == null)
                this.registerError("When parsing NewArray, index required", "Missing Token");
            this.checkToken(RBRACKET,"When parsing New, \"]\" expected");
            return astNodeBuilder.buildNewArrayExpr(this.currentToken.position,id,expr);//new NewArrayExpr(this.currentToken.position,id,expr);
        }else{
            this.registerError("When parsing New, \"(\" or \"[\" expected",
                    "Unexpected Token");
        }
        return null;
    }


    /*
	 * <CastExpression> ::= CAST ( <Type> , <Expression> )
     */
	private Expr parseCast() {
	    updateCurrentToken();
	    this.checkToken(LPAREN,"When parsing Cast, \"(\" expected");
        String type = this.parseType();
        this.checkToken(COMMA,"When parsing Cast, \",\" expected");
        Expr expr = this.parseExpression();
        this.checkToken(RPAREN, "When parsing Cast, \")\" expected");
        return astNodeBuilder.buildCastExpr(this.currentToken.position,type,expr);//new CastExpr( this.currentToken.position, type, expr);
    }


    /*
	 * <UnaryPrefix> ::= <PrefixOp> <UnaryPrefix> | <UnaryPostfix>
     * <PrefixOp> ::= - | ! | ++ | --
     */
	private Expr parseUnaryPrefix() {
	    String operator = this.parseOperator();
	    switch (operator) {
            case "-":
                updateCurrentToken();
                return astNodeBuilder.buildUnaryNegExpr(this.currentToken.position,this.parseUnaryPrefix());//new UnaryNegExpr(this.currentToken.position, this.parseUnaryPrefix());
            case "!":
                updateCurrentToken();
                return astNodeBuilder.buildUnaryNotExpr(this.currentToken.position,this.parseUnaryPrefix());//new UnaryNotExpr(this.currentToken.position, this.parseUnaryPrefix());
            case "++":
                updateCurrentToken();
                return astNodeBuilder.buildUnaryIncrExpr(this.currentToken.position,
                        this.parseUnaryPrefix(),false);//new UnaryIncrExpr(this.currentToken.position, this.parseUnaryPrefix(), false);
            case "--":
                updateCurrentToken();
                return astNodeBuilder.buildUnaryDecrExpr(this.currentToken.position,
                        this.parseUnaryPrefix(),false);//new UnaryDecrExpr(this.currentToken.position, this.parseUnaryPrefix(), false);
            default:
                return this.parseUnaryPostfix();
	    }
    }


    /*
	 * <UnaryPostfix> ::= <Primary> <PostfixOp>
     * <PostfixOp> ::= ++ | -- | EMPTY
     */
	private Expr parseUnaryPostfix() {
	    Expr primary = this.parsePrimary();
	    if(this.currentToken.spelling.equals("++")){
	        updateCurrentToken();
	        return astNodeBuilder.buildUnaryIncrExpr(this.currentToken.position,primary,true);//new UnaryIncrExpr(this.currentToken.position,primary,true);
        }else if(this.currentToken.spelling.equals("--")){
	        updateCurrentToken();
	        return astNodeBuilder.buildUnaryDecrExpr(this.currentToken.position,primary,true);//new UnaryDecrExpr(this.currentToken.position,primary,true);
        }
        return primary;
    }



    /*
     * <Primary> ::= ( <Expression> ) <ExprSuffix> | <IntegerConst> | <BooleanConst> |
     *                               <StringConst> <IdSuffix> | <Identifier> <Suffix>
     * <IdSuffix>    ::=  . <Identifier> <Suffix> | EMPTY
     * <IndexSuffix> ::=  [ <Expression> ] <IdSuffix> | EMPTY
     * <DispSuffix>  ::=  ( <Arguments> ) <IdSuffix> | EMPTY
     * <ExprSuffix>  ::=  <IdSuffix> | <IndexSuffix>
     * <Suffix>      ::=  <IdSuffix> | <DispSuffix> | <IndexSuffix>
     */

	private Expr parsePrimary() {
	    Expr tempExpr = null;
        switch (this.currentToken.kind) {
            case LPAREN: // (<Expression>)
                updateCurrentToken();
                Expr expr = this.parseExpression();
                this.checkToken(RPAREN, "When parsing (Expr), \")\" expected");
                if(currentToken.kind == LBRACKET){
                    updateCurrentToken();
                    Expr index = this.parseExpression();
                    this.checkToken(RBRACKET, "When parsing (Expr), \"]\" expected");
                    tempExpr = astNodeBuilder.buildArrayExpr(this.currentToken.position,expr,null,index);//new ArrayExpr(this.currentToken.position,expr,null,index);
                }else{
                    tempExpr = expr;
                }


                break;
            case INTCONST: // <IntegerConst>
                tempExpr = this.parseIntConst();
                return tempExpr;
            case BOOLEAN: // <BooleanConst>
                tempExpr = this.parseBoolean();
                return tempExpr;
            case STRCONST: // <StringConst>
                tempExpr = this.parseStringConst();
                break;
            case IDENTIFIER://Var Expr & DispatchExpr w/o prefix
                tempExpr = this.parseSuffix(null);
                break;
        }

        //--------------------------------------------End of cases------------------------------------------------------
        while(currentToken.kind == DOT ){
            updateCurrentToken();
            tempExpr = this.parseSuffix(tempExpr);
        }
        return tempExpr;

    }

    private Expr parseSuffix(Expr prefix){
        String identifier = parseIdentifier();
        Expr tempExpr;


        if(this.currentToken.kind == LBRACKET){
            updateCurrentToken();
            Expr varExprSuffix = this.parseExpression();
            this.checkToken(RBRACKET, "When parsing varExpr, \"]\" expected");
            tempExpr= astNodeBuilder.buildArrayExpr(this.currentToken.position,prefix,identifier,varExprSuffix);//new ArrayExpr(this.currentToken.position, prefix, identifier, varExprSuffix);
        }
        else if(this.currentToken.kind==LPAREN) {
            updateCurrentToken();
            ExprList argument = parseArguments();
            this.checkToken(RPAREN, "When parsing varExpr, \")\" expected");
            tempExpr = astNodeBuilder.buildDispatchExpr(this.currentToken.position, prefix, identifier, argument);//new DispatchExpr(this.currentToken.position, prefix, identifier, argument);
        }
        else{
            tempExpr = astNodeBuilder.buildVarExpr(this.currentToken.position, prefix, identifier);//new VarExpr( this.currentToken.position, prefix, identifier);
        }

        return tempExpr;
    }


    /*
	 * <Arguments> ::= EMPTY | <Expression> <MoreArgs>
     * <MoreArgs>  ::= EMPTY | , <Expression> <MoreArgs>
     */
	private ExprList parseArguments() {
        int position = this.currentToken.position;
	    ExprList exprList = astNodeBuilder.buildExprList(position);//new ExprList(position);
	    while (this.currentToken.kind != RPAREN) {
	        exprList.addElement(this.parseExpression());
	        if (this.currentToken.kind != COMMA ) {
	            if(this.currentToken.kind != RPAREN) {
                    this.registerError("When parsing Arguments, \",\" expected",
                            "Unexpected Token");
                }else{ break; }
            }
            updateCurrentToken();
        }
        return exprList;
    }


    //--------------------------------------------------
    /*
	 * <Parameters>  ::= EMPTY | <Formal> <MoreFormals>
     * <MoreFormals> ::= EMPTY | , <Formal> <MoreFormals
     */
	private FormalList parseParameters() {
	    int position = this.currentToken.position;
	    FormalList formalList = astNodeBuilder.buildFormalList(position);//new FormalList(position);
	    while (this.currentToken.kind != RPAREN) {
	        formalList.addElement(this.parseFormal());
	        if (this.currentToken.kind != COMMA) {
	            if(this.currentToken.kind != RPAREN){
                    this.registerError("When parsing Parameters, \\\",\\\" expected",
                            "Unexpected Token");
                }
                else{ break; }
            }
            updateCurrentToken();
        }
        return formalList;
    }


    /*
	 * <Formal> ::= <Type> <Identifier>
     */
	private Formal parseFormal() {
	    String type = this.parseType();
	    String id = this.parseIdentifier();

        return astNodeBuilder.buildFormal(this.currentToken.position, type, id);//new Formal(this.currentToken.position, type, id);
    }


    /*
	 * <Type> ::= <Identifier> <Brackets>
     * <Brackets> ::= EMPTY | [ ]
     */

	private String parseType() {
	    String id = this.parseIdentifier();

	    if(this.currentToken.kind == LBRACKET){
	        updateCurrentToken();
	        this.checkToken(RBRACKET, "When parsing Type, \\\"]\\\" expected");
	        id = id +"[]";
        }
	    return id;
    }


    //----------------------------------------
    //Terminals

	private String parseOperator() {
	    return this.currentToken.spelling;
    }


    private String parseIdentifier() {
        String identifier = this.currentToken.spelling;
	    this.checkToken(IDENTIFIER,"When parsing Identifier, Identifier expected");
	    return identifier;
    }


    private ConstStringExpr parseStringConst() {
	    ConstStringExpr constStringExpr =
                astNodeBuilder.buildConstStringExpr(this.currentToken.position,this.currentToken.spelling);
	    updateCurrentToken();
	    return constStringExpr;
    }


    private ConstIntExpr parseIntConst() {
	    ConstIntExpr constIntExpr =
                astNodeBuilder.buildConstIntExpr(this.currentToken.position,this.currentToken.spelling);
	    updateCurrentToken();
        return constIntExpr;
    }


    private ConstBooleanExpr parseBoolean() {
	    ConstBooleanExpr constBooleanExpr =
                this.astNodeBuilder.buildConstBooleanExpr(this.currentToken.position,this.currentToken.spelling);
	    updateCurrentToken();
        return constBooleanExpr;
    }

    /**
     * Updates the current Token
     * Ignores comment tokens
     */
    private void updateCurrentToken(){
	    this.currentToken = scanner.scan();
	    while(this.currentToken.kind == COMMENT){
	        this.commentMap.put(this.currentToken.position,this.currentToken.spelling);
	        this.currentToken = scanner.scan();
        }
    }

    /**
     * Throws errors
     * @param errorMessage message passed to errorHandler
     * @param compilationMessage message passed to CompilationException
     */
    private void registerError(String errorMessage,String compilationMessage){
        this.errorHandler.register(Error.Kind.PARSE_ERROR,this.filename,
                this.currentToken.position,errorMessage);
        throw new CompilationException(compilationMessage);
    }

    /**
     * checks if the current token is of the correct type and registers an error if not. Moves past the token
     * @param kind kind of the token to match
     * @param errorMessage error message to be sent to the errorHandler
     */
    private void checkToken(Token.Kind kind,String errorMessage){
        if(this.currentToken.kind != kind){
            this.registerError(errorMessage, "Unexpected Token");
        }
        updateCurrentToken();
    }
}

