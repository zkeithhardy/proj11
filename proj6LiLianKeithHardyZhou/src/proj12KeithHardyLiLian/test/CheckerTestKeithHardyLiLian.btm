class Main extends B{
    boolean a = true;
    int b = true;

    //use of undeclared type
    ood c= null;
    //variable defined twice as fields
    boolean b =false;

    B testB= new B();

    

    //dispatch expression after list of expressions
    //testB.foo()[3].equals(7);

    //proper number of arguments for method call
    //testB.foo(true);

    void bar(int a){
        a = a + 1;
	test8.foo(true);
    }
    // method name duplication
    void bar(int y, int z) {
        //use of proper types of data for operations
        y = y + true;
        //use of undefined variable
        stephanie=1;
        var z = this.foo();
        z = z * y;
        var q = (new int[4]);
        for(i = 0; i < 2; i++){
            z = z + i;
            y = z + i;
        }
        while(z < 5 || x > 6){
           foo(z).get(x).ban().bar();
           this.counter ++;
           break;
        }
        if(x == 3){
            z = z / 2;
        }else{
            y = y / 2;
        }
    }
    //method overloading
    int foo(){
        foo(d).fooo(x);
        return 6;
    }

    int dale(){
        return true;
    }
}

class B{
	int[] a;
	int b;
	void B(){
		a = new int[3];
		c = new int[1+5*c+6];
		(new A()).bar(car(a,cars(c),d,12),b);
		(new A()).bar(car(a,cars(c)),b);
	}

    int[] foo(){
    	a[3]=4;
    	return a;
    }

    int bruce(boolean boo){
        return 3;
    }
	void main() {
		//argument types do not match parameter type
		bruce(3);
		a[3] = 5;
        x = a[3];
        foo(x,y);
        var y = a.b().length;
        var z = new ban();
        cast(int,a+b.foo().get().bar(ab));
        return 6;
    }
}

//circular inheritance
class A extends C{
    void main(){

    }
}

class C extends A{
    void main(){

    }
}